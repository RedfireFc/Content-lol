-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

-- Animation IDs to detect
local animationIds = {
    ["126830014841198"] = true, ["126355327951215"] = true, ["121086746534252"] = true,
    ["18885909645"] = true, ["98456918873918"] = true, ["105458270463374"] = true,
    ["83829782357897"] = true, ["125403313786645"] = true, ["118298475669935"] = true,
    ["82113744478546"] = true, ["70371667919898"] = true, ["99135633258223"] = true,
    ["97167027849946"] = true, ["109230267448394"] = true, ["139835501033932"] = true,
    ["126896426760253"] = true,
}

-- Safe getconnections wrapper
local function safeGetConnections(signal)
    if type(getconnections) == "function" then
        return getconnections(signal)
    else
        return {}
    end
end

-- Variables
local detectionRange = 18
local toggleOn = false

-- Functions to click buttons
local function clickBlockButton()
    local gui = localPlayer:FindFirstChild("PlayerGui")
    if not gui then return end
    local mainUI = gui:FindFirstChild("MainUI")
    local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
    local blockButton = container and container:FindFirstChild("Block")
    if blockButton and blockButton:IsA("ImageButton") and blockButton.Visible then
        pcall(function() blockButton:Activate() end)
        for _, conn in ipairs(safeGetConnections(blockButton.MouseButton1Click)) do
            pcall(function() conn:Fire() end)
        end
    end
end

local function clickPunchButton(target)
    local gui = localPlayer:FindFirstChild("PlayerGui")
    if not gui then return end
    local mainUI = gui:FindFirstChild("MainUI")
    local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
    local punchButton = container and container:FindFirstChild("Punch")
    if punchButton and punchButton:IsA("ImageButton") and punchButton.Visible then
        local myChar = localPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local targetRoot = target and target:FindFirstChild("HumanoidRootPart")
        if myRoot and targetRoot then
            myRoot.CFrame = CFrame.new(myRoot.Position, targetRoot.Position)
        end
        pcall(function() punchButton:Activate() end)
        for _, conn in ipairs(safeGetConnections(punchButton.MouseButton1Click)) do
            pcall(function() conn:Fire() end)
        end
    end
end

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoBlockGui"
ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false

-- Main UI frame (contains toggleButton and slider)
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 320, 0, 140)
mainFrame.Position = UDim2.new(0.5, -160, 0.5, -70)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = ScreenGui
mainFrame.Name = "MainUI"

-- Title label
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Guest 1337 | Triplex & Redfire Hub"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextSize = 20
titleLabel.Parent = mainFrame

-- Auto Block & Auto Punch toggle button (fixed position)
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 140, 0, 40)
toggleButton.Position = UDim2.new(0.5, -70, 0, 40)
toggleButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- black background
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- white text
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 16
toggleButton.TextWrapped = true
toggleButton.Text = "Auto Block & Auto Punch"
toggleButton.Parent = mainFrame

toggleButton.MouseButton1Click:Connect(function()
    toggleOn = not toggleOn
    if toggleOn then
        toggleButton.Text = "Auto Block & Auto Punch (ON)"
        toggleButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    else
        toggleButton.Text = "Auto Block & Auto Punch (OFF)"
        toggleButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    end
end)

-- --- Custom Slider UI ---
local sliderFrame = Instance.new("Frame")
sliderFrame.Size = UDim2.new(0, 280, 0, 30)
sliderFrame.Position = UDim2.new(0.5, -140, 0, 95)
sliderFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
sliderFrame.BorderSizePixel = 0
sliderFrame.Parent = mainFrame

local sliderFill = Instance.new("Frame")
sliderFill.Size = UDim2.new((detectionRange - 5) / 45, 0, 1, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
sliderFill.BorderSizePixel = 0
sliderFill.Parent = sliderFrame

local sliderKnob = Instance.new("ImageButton")
sliderKnob.Size = UDim2.new(0, 30, 0, 30)
sliderKnob.Position = UDim2.new((detectionRange - 5) / 45, -15, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
sliderKnob.BorderSizePixel = 0
sliderKnob.Parent = sliderFrame
sliderKnob.AutoButtonColor = false
sliderKnob.Image = ""

local sliderValueLabel = Instance.new("TextLabel")
sliderValueLabel.Size = UDim2.new(0, 80, 0, 30)
sliderValueLabel.Position = UDim2.new(1, 10, 0, 0)
sliderValueLabel.BackgroundTransparency = 1
sliderValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
sliderValueLabel.Font = Enum.Font.SourceSansBold
sliderValueLabel.TextSize = 18
sliderValueLabel.Text = detectionRange .. " Studs"
sliderValueLabel.Parent = sliderFrame

local function clamp(val, min, max)
    if val < min then return min end
    if val > max then return max end
    return val
end

local dragging = false

local function updateSlider(inputX)
    local absPos = sliderFrame.AbsolutePosition
    local absSize = sliderFrame.AbsoluteSize

    local relativeX = clamp(inputX - absPos.X, 0, absSize.X)
    local percent = relativeX / absSize.X
    detectionRange = math.floor(5 + percent * 45 + 0.5)

    sliderFill.Size = UDim2.new(percent, 0, 1, 0)
    sliderKnob.Position = UDim2.new(percent, -15, 0, 0)
    sliderValueLabel.Text = detectionRange .. " Studs"
end

local function inputBegan(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        updateSlider(input.Position.X)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end

local function inputChanged(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        updateSlider(input.Position.X)
    end
end

sliderKnob.InputBegan:Connect(inputBegan)
sliderKnob.InputChanged:Connect(inputChanged)
sliderFrame.InputBegan:Connect(inputBegan)
sliderFrame.InputChanged:Connect(inputChanged)

-- Movable small Toggle button to show/hide mainFrame
local toggleGuiButton = Instance.new("TextButton")
toggleGuiButton.Name = "ToggleButton"
toggleGuiButton.Size = UDim2.new(0, 50, 0, 50)
toggleGuiButton.Position = UDim2.new(0, 20, 0, 20)
toggleGuiButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- black background
toggleGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- white text
toggleGuiButton.Font = Enum.Font.SourceSansBold
toggleGuiButton.TextSize = 18
toggleGuiButton.Text = "Toggle"
toggleGuiButton.Parent = ScreenGui
toggleGuiButton.ZIndex = 10 -- make sure it's on top

local draggingToggle = false
local dragInput, dragStart, startPos

toggleGuiButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        draggingToggle = true
        dragStart = input.Position
        startPos = toggleGuiButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                draggingToggle = false
            end
        end)
    end
end)

toggleGuiButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

RunService.RenderStepped:Connect(function()
    if draggingToggle and dragInput then
        local delta = dragInput.Position - dragStart
        local newPos = UDim2.new(
            clamp(startPos.X.Scale, 0, 1),
            clamp(startPos.X.Offset + delta.X, 0, workspace.CurrentCamera.ViewportSize.X - toggleGuiButton.AbsoluteSize.X),
            clamp(startPos.Y.Scale, 0, 1),
            clamp(startPos.Y.Offset + delta.Y, 0, workspace.CurrentCamera.ViewportSize.Y - toggleGuiButton.AbsoluteSize.Y)
        )
        toggleGuiButton.Position = newPos
    end
end)

toggleGuiButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = not mainFrame.Visible
end)

-- Auto Block + Punch main loop
RunService.RenderStepped:Connect(function()
    if not toggleOn then return end
    local myChar = localPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= localPlayer and otherPlayer.Character then
            local root = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
            if root and humanoid and humanoid.Health > 0 then
                local dist = (root.Position - myRoot.Position).Magnitude
                if dist <= detectionRange then
                    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                        local anim = track.Animation
                        local id = anim and anim.AnimationId and string.match(anim.AnimationId, "%d+")
                        if id and animationIds[id] then
                            clickBlockButton()
                            clickPunchButton(otherPlayer.Character)
                            return -- once per frame for performance
                        end
                    end
                end
            end
        end
    end
end)
