-- Lead Hub

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local lp = LocalPlayer
-- Rayfield
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "Lead Hub",
    LoadingTitle = "Lead Hub",
    LoadingSubtitle = "by Triplex",
    ConfigurationSaving = {Enabled = true, FolderName = "LeadHub", FileName = "Settings"},
    Discord = {Enabled = false},
    KeySystem = false
})

-- Tabs
local CombatTab = Window:CreateTab("Combat", 4483362458)
local GeneratorTab = Window:CreateTab("Generators", 4483362458)
local ESPTab = Window:CreateTab("ESP", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

-- Audio Block IDs
local autoBlockTriggerSounds = {
    ["102228729296384"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["136323728355613"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["82221759983649"] = true,
    ["81702359653578"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["109431876587852"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true,
    ["12222216"] = true,
}

-- State (existing)
local autoBlockAudioOn = true
local autoPunchOn = true
local infiniteStamina = true
local detectionRange = 10
local apRange = 7 -- punch range in studs
local generatorCooldown = 2.5
local flingPunchOn = false
local flingPower = 10000
local hiddenfling = false
local looseFacing = false

-- Infinite Stamina
local function enableInfiniteStamina()
    local success, StaminaModule = pcall(function()
        return require(ReplicatedStorage.Systems.Character.Game.Sprinting)
    end)
    if not success or not StaminaModule then return end
    StaminaModule.StaminaLossDisabled = true
    task.spawn(function()
        while infiniteStamina do
            task.wait(0.1)
            StaminaModule.Stamina = StaminaModule.MaxStamina
            if StaminaModule.StaminaChanged then
                pcall(function() StaminaModule.StaminaChanged:Fire() end)
            end
        end
    end)
end
enableInfiniteStamina()

-- UI Toggles (existing)
local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
local detectionCircles = {} -- store all killer circles
local killerCirclesVisible = true

-- Function to add circle to a killer
-- create once, reuse
local groundCastParams = RaycastParams.new()
groundCastParams.FilterType = Enum.RaycastFilterType.Exclude
groundCastParams.IgnoreWater = true

local function setCircleAtGround(killer, circle)
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp or not circle then return end

    -- exclude this character from the raycast
    groundCastParams.FilterDescendantsInstances = {killer}

    -- raycast straight down to find floor
    local origin = hrp.Position
    local result = workspace:Raycast(origin, Vector3.new(0, -1000, 0), groundCastParams)
    local groundY = result and result.Position.Y or (origin.Y - 3)

    -- local offset from HRP down to the ground (+tiny lift to avoid z-fighting)
    local offsetY = (groundY - origin.Y) + 0.03

    -- lay cylinder flat + move to ground under HRP
    circle.CFrame = CFrame.new(0, offsetY, 0) * CFrame.Angles(math.rad(90), 0, 0)
end

local function addKillerCircle(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if detectionCircles[killer] then return end -- already has one

    local hrp = killer.HumanoidRootPart

    local circle = Instance.new("CylinderHandleAdornment")
    circle.Name = "KillerDetectionCircle"
    circle.Adornee = hrp
    circle.Color3 = Color3.fromRGB(255, 0, 0)
    circle.AlwaysOnTop = true
    circle.ZIndex = 0
    circle.Transparency = 0.7
    circle.Radius = detectionRange
    circle.Height = 0.1
    circle.Parent = hrp

    detectionCircles[killer] = circle

    -- position once immediately
    setCircleAtGround(killer, circle)
end



-- Function to remove circle from a killer
local function removeKillerCircle(killer)
    if detectionCircles[killer] then
        detectionCircles[killer]:Destroy()
        detectionCircles[killer] = nil
    end
end

-- Refresh all circles
local function refreshKillerCircles()
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if killerCirclesVisible then
            addKillerCircle(killer)
        else
            removeKillerCircle(killer)
        end
    end
end

-- Keep radius + position updated
RunService.RenderStepped:Connect(function()
    for killer, circle in pairs(detectionCircles) do
        if circle and circle.Parent then
            circle.Radius = detectionRange / 1.5
            setCircleAtGround(killer, circle) -- <-- keep pinned to ground
        end
    end
end)


-- Hook into killers being added/removed
KillersFolder.ChildAdded:Connect(function(killer)
    if killerCirclesVisible then
        task.spawn(function()
            -- Wait until HRP exists (max 5s timeout)
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then
                addKillerCircle(killer)
            end
        end)
    end
end)

KillersFolder.ChildRemoved:Connect(function(killer)
    removeKillerCircle(killer)
end)

CombatTab:CreateToggle({Name="Auto Block", CurrentValue=true, Callback=function(state) AutoBlockAudioOn = state end})
CombatTab:CreateToggle({Name="Auto Punch", CurrentValue=true, Callback=function(val) AutoPunch = val end})
CombatTab:CreateToggle({Name="Range Visual", CurrentValue=true, Callback=function(state) killerCirclesVisible = state refreshKillerCircles() end})
CombatTab:CreateToggle({Name="Fling Punch", CurrentValue=false, Callback=function(val) flingPunchOn = val end})
CombatTab:CreateToggle({Name="Infinite Stamina", CurrentValue=true, Callback=function(val) infiniteStamina = val enableInfiniteStamina() end})
CombatTab:CreateInput({Name="Detection Range (studs)", PlaceholderText="10", RemoveTextAfterFocusLost=false, Callback=function(txt) detectionRange = tonumber(txt) or detectionRange end})

-- Misc
MiscTab:CreateButton({Name="Copy Discord Invite", Callback=function()
    pcall(function() setclipboard("https://discord.gg/baXMxMz5JZ") end)
end})

-- AUTO PUNCH
local aiming = false

local function AutoPunch(target)
    if not target then return end
    local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
    remote:FireServer("UseActorAbility", "Punch", target)
    task.wait(0.05)
    remote:FireServer("UseActorAbility", "Punch", target)
end

RunService.Stepped:Connect(function()
    if autoPunchOn then
        local char = lp.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= lp and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (plr.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                if dist <= 13 then
                    AutoPunch(plr.Character)
                end
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if not autoPunchOn or aiming then return end

    local gui = lp:FindFirstChild("PlayerGui")
    local chargesObj = gui and gui:FindFirstChild("MainUI")
        and gui.MainUI:FindFirstChild("AbilityContainer")
        and gui.MainUI.AbilityContainer:FindFirstChild("Punch")
        and gui.MainUI.AbilityContainer.Punch:FindFirstChild("Charges")

    if chargesObj and tostring(chargesObj.Text) == "1" then
        local target = closestKiller()
        local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if target and root then
            aiming = true
            firePunch()
            local startTime = tick()
            task.spawn(function()
                while tick() - startTime < 2 and root and target do
                    root.CFrame = CFrame.new(root.Position, target.Position)
                    task.wait()
                end
                aiming = false
            end)
        end
    end
end)

-- ===== Robust Sound Auto Block  =====
local soundHooks = {}     
local soundBlockedUntil = {} 

-- Helpers
local function extractNumericSoundId(sound)
    if not sound or not sound.SoundId then return nil end
    local sid = tostring(sound.SoundId)
    return sid:match("%d+")
end

local function getSoundWorldPosition(sound)
    if not sound then return nil end
    if sound.Parent and sound.Parent:IsA("BasePart") then
        return sound.Parent.Position, sound.Parent
    end
    if sound.Parent and sound.Parent:IsA("Attachment") and sound.Parent.Parent and sound.Parent.Parent:IsA("BasePart") then
        return sound.Parent.Parent.Position, sound.Parent.Parent
    end
    local found = sound.Parent and sound.Parent:FindFirstChildWhichIsA("BasePart", true)
    if found then
        return found.Position, found
    end
    return nil, nil
end

local function getCharacterFromDescendant(inst)
    if not inst then return nil end
    local model = inst:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then
        return model
    end
    return nil
end

local function isPointInsidePart(part, point)
    if not (part and point) then return false end
    local rel = part.CFrame:PointToObjectSpace(point)
    local half = part.Size * 0.5
    return math.abs(rel.X) <= half.X + 0.001 and
           math.abs(rel.Y) <= half.Y + 0.001 and
           math.abs(rel.Z) <= half.Z + 0.001
end

-- safety/defaults (won't clobber globals if already set)
local LOCAL_BLOCK_COOLDOWN = LOCAL_BLOCK_COOLDOWN or 0.7
local lastLocalBlockTime = lastLocalBlockTime or 0

local SMOOTHING_LERP = SMOOTHING_LERP or 0.25
local PRED_SECONDS_FORWARD = PRED_SECONDS_FORWARD or 0.15
local PRED_SECONDS_LATERAL = PRED_SECONDS_LATERAL or 0.12
local ANG_TURN_MULTIPLIER = ANG_TURN_MULTIPLIER or 2
local PRED_MAX_FORWARD = PRED_MAX_FORWARD or 5
local PRED_MAX_LATERAL = PRED_MAX_LATERAL or 3

-- Normal block attempt
local function attemptBlockForSound(sound, idParam)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end

    local id = idParam or extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end

    if t < lastLocalBlockTime + LOCAL_BLOCK_COOLDOWN then
        return
    end

    local lp = Players.LocalPlayer
    local myChar = lp and lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPos or not soundPart then return end

    local char = getCharacterFromDescendant(soundPart)
    local plr = char and Players:GetPlayerFromCharacter(char)
    if not plr or plr == lp then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local range = detectionRange or 10
    local detectionRangeSq = range * range

    local dvec = hrp.Position - myRoot.Position
    local distSq = dvec.X * dvec.X + dvec.Y * dvec.Y + dvec.Z * dvec.Z
    if detectionRangeSq and distSq > detectionRangeSq then
        return
    end

    if cachedCooldown and cachedCooldown.Text ~= "" then
        return
    end

    if facingCheckEnabled and type(isFacing) == "function" and not isFacing(myRoot, hrp) then
        return
    end

    -- FIRE remote calls (remote-only)
    pcall(function() fireRemoteBlock() end)

    if doubleblocktech and cachedCharges and cachedCharges.Text == "1" then
        pcall(function() fireRemotePunch() end)
    end

    lastLocalBlockTime = tick()
    soundBlockedUntil[sound] = t + 1.2
end

-- Predictive / anti-flick path (runs when antiFlickOn is true)
local function attemptBDParts(sound)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end

    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end

    local lp = Players.LocalPlayer
    local myChar = lp and lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPos or not soundPart then return end

    local char = getCharacterFromDescendant(soundPart)
    local plr = char and Players:GetPlayerFromCharacter(char)
    if not plr or plr == lp then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local Debris = game:GetService("Debris")

    if antiFlickOn then
        local basePartSize = Vector3.new(5.5, 7.5, 8.5)
        local partSize = basePartSize * (blockPartsSizeMultiplier or 1)
        local count = math.max(1, antiFlickParts or 4)
        local base  = antiFlickBaseOffset or 2.5
        local step  = antiFlickOffsetStep or 0.2
        local lifeTime = 0.2

        task.spawn(function()
            local blocked = false
            task.wait(antiFlickDelay or 0)
            for i = 1, count do
                if not hrp or not myRoot then break end

                local dist = base + (i - 1) * step

                local st = (type(killerState) == "table" and killerState[char]) or { vel = hrp.Velocity or Vector3.new(), angVel = 0 }
                local vel = st.vel or hrp.Velocity or Vector3.new()

                local forwardSpeed = vel:Dot(hrp.CFrame.LookVector)
                local lateralSpeed = vel:Dot(hrp.CFrame.RightVector)

                local pStrength = (type(predictionStrength) == "number" and predictionStrength) or 1
                local pTurn = (type(predictionTurnStrength) == "number" and predictionTurnStrength) or 1

                local forwardPredictRaw = forwardSpeed * PRED_SECONDS_FORWARD * pStrength
                local lateralPredictRaw = lateralSpeed * PRED_SECONDS_LATERAL * pStrength
                local turnLateralRaw    = st.angVel * ANG_TURN_MULTIPLIER * pTurn

                local forwardClamp = PRED_MAX_FORWARD * pStrength
                local lateralClamp = PRED_MAX_LATERAL * pStrength
                local turnClamp    = PRED_MAX_LATERAL * pTurn

                local forwardPredict = math.clamp(forwardPredictRaw, -forwardClamp, forwardClamp)
                local lateralPredict = math.clamp(lateralPredictRaw, -lateralClamp, lateralClamp)
                local turnLateral = math.clamp(turnLateralRaw, -turnClamp, turnClamp)

                local forwardDist = dist + forwardPredict

                local spawnPos = hrp.Position
                                + hrp.CFrame.LookVector * forwardDist
                                + hrp.CFrame.RightVector * (lateralPredict + turnLateral)

                local part = Instance.new("Part")
                part.Name = "AntiFlickZone"
                part.Size = partSize
                part.Transparency = 0.45
                part.Anchored = true
                part.CanCollide = false
                part.CFrame = CFrame.new(spawnPos, hrp.Position)
                part.BrickColor = BrickColor.new("Bright blue")
                part.Parent = workspace

                Debris:AddItem(part, lifeTime)

                if isPointInsidePart(part, myRoot.Position) then
                    blocked = true
                else
                    local touching = {}
                    pcall(function() touching = myRoot:GetTouchingParts() end)
                    for _, p in ipairs(touching) do
                        if p == part then
                            blocked = true
                            break
                        end
                    end
                end

                if blocked then
                    if not (facingCheckEnabled and type(isFacing) == "function" and not isFacing(myRoot, hrp)) then
                        pcall(function() fireRemoteBlock() end)

                        if doubleblocktech and cachedCharges and cachedCharges.Text == "1" then
                            pcall(function() fireRemotePunch() end)
                        end
                        soundBlockedUntil[sound] = t + 1.2
                    end
                    break
                end

                if stagger and stagger > 0 then
                    task.wait(stagger)
                else
                    task.wait(0)
                end
            end
        end)
        return
    end
end

-- Hook a sound (connect play/IsPlaying and cleanup)
local function hookSound(sound)
    if not sound or not sound:IsA("Sound") then return end
    if soundHooks[sound] then return end

    local preId = extractNumericSoundId(sound)

    local playedConn = sound.Played:Connect(function()
        if not autoBlockAudioOn then return end
        if not antiFlickOn then
            task.spawn(attemptBlockForSound, sound, preId)
        else
            task.spawn(attemptBDParts, sound, preId)
        end
    end)

    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if sound.IsPlaying and autoBlockAudioOn then
            if not antiFlickOn then
                task.spawn(attemptBlockForSound, sound, preId)
            else
                task.spawn(attemptBDParts, sound, preId)
            end
        end
    end)

    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        soundHooks[sound] = nil
        soundBlockedUntil[sound] = nil
    end)

    soundHooks[sound] = {playedConn, propConn, destroyConn, id = preId}

    if sound.IsPlaying then
        task.spawn(function()
            if not antiFlickOn then
                attemptBlockForSound(sound, preId)
            else
                attemptBDParts(sound, preId)
            end
        end)
    end
end

-- Hook existing Sounds in the Killers folder (fallbacks if missing)
local KillersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
if not KillersFolder then
    KillersFolder = workspace:FindFirstChild("Killers") or workspace:FindFirstChild("Enemies")
end

if KillersFolder then
    for _, desc in ipairs(KillersFolder:GetDescendants()) do
        if desc:IsA("Sound") then
            pcall(hookSound, desc)
        end
    end
    KillersFolder.DescendantAdded:Connect(function(desc)
        if desc:IsA("Sound") then
            pcall(hookSound, desc)
        end
    end)
else
    -- fallback to hooking broader workspace (if Killers folder isn't present)
    for _, desc in ipairs(workspace:GetDescendants()) do
        if desc:IsA("Sound") then
            pcall(hookSound, desc)
        end
    end
    workspace.DescendantAdded:Connect(function(desc)
        if desc:IsA("Sound") then
            pcall(hookSound, desc)
        end
    end)
end
-- ===== End Robust Sound Auto Block =====

--================= GENERATORS =================
local function GeneratorOnce()
    local IngameMapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
    local SubMapFolder = IngameMapFolder and IngameMapFolder:FindFirstChild("Map")
    if SubMapFolder then
        for _, g in ipairs(SubMapFolder:GetChildren()) do
            if g.Name == "Generator" and g.Progress.Value < 100 then
                wait(0.5)
                g.Remotes.RE:FireServer()
            end
        end
    end
end

-- Auto Generator Toggle
GeneratorTab:CreateToggle({
    Name = "Auto Generator",
    CurrentValue = false,
    Callback = function(enabled)
        if GeneratorTab._loop then GeneratorTab._loop:Disconnect() GeneratorTab._loop = nil end
        if enabled then
            GeneratorTab._timer = 0
            GeneratorTab._loop = RunService.Heartbeat:Connect(function(dt)
                GeneratorTab._timer = GeneratorTab._timer + dt
                if GeneratorTab._timer >= generatorCooldown then
                    GeneratorTab._timer = 0
                    GeneratorOnce()
                end
            end)
        end
    end
})

-- Auto Generator Slider
GeneratorTab:CreateSlider({
    Name = "Auto Generator Delay",
    Range = {2.5, 5},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = generatorCooldown,
    Callback = function(val)
        generatorCooldown = val
    end
})
--================= ESP =================
local espKillers = false
local espSurvivors = false
local espItems = false
local espGenerators = false

-- Utility: create or reuse highlight
local function getOrCreateHighlight(obj, color, fillTrans, outlineTrans)
    wait(1) -- delay
    for i = 1, 3 do
        local h = obj:FindFirstChild("ESP_Highlight")
        if not h then
            h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.Adornee = obj
            h.Parent = obj
        end
        h.FillColor = color
        h.OutlineColor = Color3.new(0,0,0)
        h.FillTransparency = fillTrans
        h.OutlineTransparency = outlineTrans - (i * 0.2)
        return h
    end
end

-- Utility: clear highlight
local function clearESP(obj)
    local h = obj:FindFirstChild("ESP_Highlight")
    if h then h:Destroy() end
    local b = obj:FindFirstChild("ESP_Billboard")
    if b then b:Destroy() end
end

-- Apply ESP for items
local function applyItemESP(obj)
    getOrCreateHighlight(obj, Color3.fromRGB(0,0,139), 0.6, 0.6)

    if not obj:FindFirstChild("ESP_Billboard") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP_Billboard"
        billboard.Size = UDim2.new(0,100,0,30)
        billboard.StudsOffset = Vector3.new(0,3,0)
        billboard.AlwaysOnTop = true
        billboard.Adornee = obj

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1,0,1,0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(0,0,139)
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.TextSize = 14
        textLabel.Text = obj.Name
        textLabel.Parent = billboard

        billboard.Parent = obj
    end
end

-- ESP Updater (runs slower)
task.spawn(function()
    while true do
        local mapFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ingame") and Workspace.Map.Ingame:FindFirstChild("Map")

        -- Killers
        if espKillers then
            local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
            if killers then
                for _, k in ipairs(killers:GetChildren()) do
                    getOrCreateHighlight(k, Color3.fromRGB(255,0,0), 0.8, 0.5)
                end
            end
        else
            local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
            if killers then for _, k in ipairs(killers:GetChildren()) do clearESP(k) end end
        end

        -- Survivors
        if espSurvivors then
            local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
            if survivors then
                for _, s in ipairs(survivors:GetChildren()) do
                    getOrCreateHighlight(s, Color3.fromRGB(255,255,255), 0.8, 0.5)
                end
            end
        else
            local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
            if survivors then for _, s in ipairs(survivors:GetChildren()) do clearESP(s) end end
        end

        -- Items & Generators
        if mapFolder then
            for _, obj in ipairs(mapFolder:GetChildren()) do
                if espItems and (obj.Name == "Medkit" or obj.Name == "BloxyCola") then
                    applyItemESP(obj)
                elseif not espItems and (obj.Name == "Medkit" or obj.Name == "BloxyCola") then
                    clearESP(obj)
                end

                if espGenerators and obj.Name == "Generator" then
                    local progressVal = obj:FindFirstChild("Progress")
                    if progressVal and progressVal.Value < 100 then
                        getOrCreateHighlight(obj, Color3.fromRGB(255,255,0), 0.6, 0.6)
                    else
                        clearESP(obj)
                    end
                elseif not espGenerators and obj.Name == "Generator" then
                    clearESP(obj)
                end
            end
        end

        task.wait(0.5) -- ✅ only checks every half second instead of spamming every frame
    end
end)

ESPTab:CreateToggle({
    Name = "Killers ESP",
    CurrentValue = false,
    Callback = function(val)
        espKillers = val
        if not val then
            local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
            if killers then
                for _, k in ipairs(killers:GetChildren()) do
                    local h = k:FindFirstChild("ESP_Highlight")
                    if h then h:Destroy() end
                end
            end
        end
    end
})

ESPTab:CreateToggle({
    Name = "Survivors ESP",
    CurrentValue = false,
    Callback = function(val)
        espSurvivors = val
        if not val then
            local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
            if survivors then
                for _, s in ipairs(survivors:GetChildren()) do
                    local h = s:FindFirstChild("ESP_Highlight")
                    if h then h:Destroy() end
                end
            end
        end
    end
})

ESPTab:CreateToggle({
    Name = "Items ESP",
    CurrentValue = false,
    Callback = function(val)
        espItems = val
        if not val then
            local mapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map")
            if mapFolder then
                for _, obj in ipairs(mapFolder:GetChildren()) do
                    if obj.Name == "Medkit" or obj.Name == "BloxyCola" then
                        local h = obj:FindFirstChild("ESP_Highlight")
                        if h then h:Destroy() end
                        local b = obj:FindFirstChild("ESP_Billboard")
                        if b then b:Destroy() end
                    end
                end
            end
        end
    end
})

ESPTab:CreateToggle({
    Name = "Generators ESP",
    CurrentValue = false,
    Callback = function(val)
        espGenerators = val
        if not val then
            local mapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map")
            if mapFolder then
                for _, obj in ipairs(mapFolder:GetChildren()) do
                    if obj.Name == "Generator" then
                        local h = obj:FindFirstChild("ESP_Highlight")
                        if h then h:Destroy() end
                    end
                end
            end
        end
    end
})

--================= CONFIG =================
Rayfield:LoadConfiguration()
